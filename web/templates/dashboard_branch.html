<script>
  const USER_ID = "{{ user_id }}";

  // --- DOM Elements ---
  const qs = (s, el = document) => el.querySelector(s);
  const elRepoList = qs('#repoList');
  const elDayBranch = qs('#dayBranch');
  const elDetail = qs('#detail');
  const elRepoFilter = qs('#repoFilter');
  const elRepoStamp = qs('#repoStamp');
  const elBranchStamp = qs('#branchStamp');
  const elDetailStamp = qs('#detailStamp');

  // [OPTIMIZED] Group state variables into a single object for better management.
  const state = {
    allRepos: [],
    selectedRepo: null, // "owner/repo"
    branchesCache: {}, // { repo: [{name, sha}, ...] }
    commitsCache: {}, // { "repo|branch": [commits] }
    repoFreshMap: {}, // { repo_full_name: boolean }
    openedBranches: new Set(), // UI state: `${repo}|${branch}`
    selectedCommit: null, // UI state: {repo, sha}
  };

  // --- Initialization & Periodic Refresh ---
  document.addEventListener('DOMContentLoaded', async () => {
    setVH();
    await loadRepos();
    wireEvents();
    stampAll();
    // [OPTIMIZED] Refresh interval is longer and smarter.
    setInterval(periodicRefresh, 5 * 60 * 1000); // Refresh every 5 minutes
  });

  function wireEvents() {
    elRepoFilter.addEventListener('input', renderRepos);
    qs('#btnSync').addEventListener('click', periodicRefresh);
  }

  // --- Utils ---
  function stamp(el) {
    const now = new Date().toLocaleString('ko-KR', { timeZone: 'Asia/Seoul', hour12: false });
    el.textContent = `마지막 새로고침: ${now} (KST)`;
  }
  function stampAll() { [elRepoStamp, elBranchStamp, elDetailStamp].forEach(el => el && stamp(el)); }

  function timeAgo(d) {
    const seconds = Math.floor((Date.now() - d.getTime()) / 1000);
    if (seconds < 5) return '방금';
    const units = [['일', 86400], ['시간', 3600], ['분', 60]];
    for (const [name, s] of units) {
      const v = Math.floor(seconds / s);
      if (v >= 1) return `${v}${name} 전`;
    }
    return `${seconds}초 전`;
  }

  function sortBranches(list) {
    const hasMain = list.some(b => (b.name || '') === 'main');
    const byName = (a, b) => (a.name || '').localeCompare(b.name || '');
    if (!hasMain) return [...list].sort(byName);
    return [...list].sort((a, b) => {
      if ((a.name || '') === 'main') return -1;
      if ((b.name || '') === 'main') return 1;
      return byName(a, b);
    });
  }
  
  function escapeHtml(s) {
    return (s || '').replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m]));
  }
  
  function setVH() { document.documentElement.style.setProperty('--vh', `${window.innerHeight}px`); }
  window.addEventListener('resize', setVH);

  // --- API ---
  async function apiGet(url, params = {}) {
    const q = new URLSearchParams(params);
    const fullUrl = url + (q.toString() ? `?${q}` : '');
    try {
      const res = await fetch(fullUrl);
      if (!res.ok) {
        if (res.status === 401) window.location.href = "{{ url_for('index') }}";
        throw new Error(`API Error: ${res.status} ${res.statusText}`);
      }
      return res.json();
    } catch (e) {
      console.error(`Failed to fetch from ${fullUrl}:`, e);
      throw e; // Re-throw to let callers handle it
    }
  }

  // --- Repos ---
  async function loadRepos() {
    const data = await apiGet('/api/my_repos');
    state.allRepos = data.repos || [];
    renderRepos();
    stamp(elRepoStamp);
  }

  function renderRepos() {
    const f = (elRepoFilter.value || '').toLowerCase();
    const frag = document.createDocumentFragment();
    state.allRepos
      .filter(r => (r.full_name || '').toLowerCase().includes(f))
      .forEach(r => {
        const item = document.createElement('button');
        item.className = 'repo-item';
        item.title = r.full_name;
        item.onclick = () => selectRepo(r.full_name);

        const isFresh = !!state.repoFreshMap[r.full_name];
        item.innerHTML = `
          <div class="repo-left">
            ${isFresh ? '<span class="green-dot" title="5분 이내 푸시"></span>' : '<span class="dot-placeholder"></span>'}
            <span class="repo-name">${escapeHtml(r.name || r.full_name)}</span>
          </div>
          <div class="repo-meta">
            ${r.pushed_at ? `pushed ${timeAgo(new Date(r.pushed_at))}` : ''}
          </div>
        `;
        frag.appendChild(item);
      });
    elRepoList.replaceChildren(frag);
  }

  // --- Branches ---
  async function selectRepo(full_name) {
    state.selectedRepo = full_name;
    elDayBranch.innerHTML = '브랜치 불러오는 중...';
    elDetail.innerHTML = '왼쪽에서 커밋을 선택하세요.'; // Reset detail view

    const data = await apiGet('/api/branches', { repo: full_name });
    const branches = sortBranches(data.branches || []);
    state.branchesCache[full_name] = branches;

    // [OPTIMIZED] Do NOT pre-fetch commits. Just render the branch list.
    const frag = document.createDocumentFragment();
    branches.forEach(b => {
      const key = `${full_name}|${b.name}`;
      const card = document.createElement('div');
      card.className = 'branch-card';
      card.innerHTML = `
        <div class="branch-head">
          <div class="branch-title branch-left">
            <span class="dot-placeholder"></span>
            <span class="name">${escapeHtml(b.name)}</span>
          </div>
          <div class="branch-info">
            <span class="tag">C ?</span>
            <span class="branch-meta">—</span>
          </div>
          <div class="open-btn">
            <button class="btn">열기</button>
          </div>
        </div>
        <div class="commit-panel" style="display: none;"></div>
      `;
      
      const btn = card.querySelector('.btn');
      btn.onclick = () => toggleBranchCommits(full_name, b.name, card);

      // Restore UI state if this branch was previously opened
      if (state.openedBranches.has(key)) {
        toggleBranchCommits(full_name, b.name, card);
      }
      frag.appendChild(card);
    });

    elDayBranch.replaceChildren(frag);
    stamp(elBranchStamp);
  }
  
  async function toggleBranchCommits(repo, branch, cardElement) {
    const key = `${repo}|${branch}`;
    const panel = cardElement.querySelector('.commit-panel');
    const btn = cardElement.querySelector('.btn');
    const isOpened = panel.style.display !== 'none';

    if (isOpened) {
      panel.style.display = 'none';
      btn.textContent = '열기';
      state.openedBranches.delete(key);
    } else {
      panel.style.display = 'block';
      panel.innerHTML = '커밋 조회 중...';
      btn.textContent = '닫기';
      state.openedBranches.add(key);
      await loadCommitsForBranch(repo, branch, cardElement);
    }
  }

  async function loadCommitsForBranch(repo, branch, cardEl) {
    const key = `${repo}|${branch}`;
    const data = await apiGet('/api/commits', { repo, branch });
    state.commitsCache[key] = data.commits || [];
    const commits = state.commitsCache[key];

    // Update branch header with commit info
    const headEl = cardEl.querySelector('.branch-head');
    const latestCommit = commits[0];
    const isFresh = latestCommit ? (Date.now() - new Date(latestCommit.date).getTime()) <= 5 * 60 * 1000 : false;
    
    headEl.querySelector('.tag').textContent = `C ${commits.length}`;
    headEl.querySelector('.branch-meta').textContent = latestCommit ? new Date(latestCommit.date).toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' }) : '—';
    headEl.querySelector('.dot-placeholder').outerHTML = isFresh 
      ? '<span class="green-dot" title="5분 이내 커밋"></span>' 
      : '<span class="dot-placeholder"></span>';
    
    // Render commit list
    const panel = cardEl.querySelector('.commit-panel');
    if (!commits.length) {
      panel.innerHTML = '커밋 없음';
      return;
    }
    
    const frag = document.createDocumentFragment();
    commits.forEach(c => {
      const item = document.createElement('div');
      item.className = 'commit-item';
      item.innerHTML = `
        <div style="display: flex; align-items: center; gap: 6px;">
          <span>${escapeHtml(c.message || '(no message)')}</span>
        </div>
        <div style="display: flex; align-items: center; gap: 6px;">
          <span class="sha">${(c.sha || '').slice(0, 7)}</span>
        </div>
      `;
      item.onclick = () => {
        state.selectedCommit = { repo, sha: c.sha };
        showCommitDetail(repo, c.sha);
      };
      frag.appendChild(item);
    });
    panel.replaceChildren(frag);

    updateRepoFreshStatus(repo);
  }
  
  function updateRepoFreshStatus(repoFullName) {
    const branches = state.branchesCache[repoFullName] || [];
    let isRepoFresh = false;
    for (const b of branches) {
      const key = `${repoFullName}|${b.name}`;
      const topCommit = (state.commitsCache[key] || [])[0];
      if (topCommit && (Date.now() - new Date(topCommit.date).getTime()) <= 5 * 60 * 1000) {
        isRepoFresh = true;
        break;
      }
    }
    if (state.repoFreshMap[repoFullName] !== isRepoFresh) {
      state.repoFreshMap[repoFullName] = isRepoFresh;
      renderRepos(); // Re-render repo list to update the dot
    }
  }

  // --- Commit Detail ---
  async function showCommitDetail(repo, sha) {
    elDetail.textContent = '상세 조회 중...';
    const d = await apiGet('/api/commit_detail', { repo, sha });
    const kst = d.date ? new Date(d.date).toLocaleString("ko-KR", { timeZone: "Asia/Seoul" }) : '—';
    const stats = d.stats || {};
    elDetail.innerHTML = `
      <div class="detail-wrap">
        <div class="kv">
          <dl>
            <dt>제목</dt><dd><strong>${escapeHtml(d.message || '')}</strong></dd>
            <dt>작성자</dt><dd>${escapeHtml(d.author || '')}</dd>
            <dt>날짜(KST)</dt><dd>${kst}</dd>
            <dt>SHA</dt><dd><code>${d.sha}</code></dd>
          </dl>
        </div>
        <div class="kv">
          <dl>
            <dt>변경</dt><dd>총 ${stats.total ?? 0} (<span class="plus">+${stats.additions ?? 0}</span> / <span class="minus">-${stats.deletions ?? 0}</span>)</dd>
          </dl>
          <div class="only-link" style="margin-top:6px"><a href="${d.html_url}" target="_blank" rel="noopener">GitHub에서 보기</a></div>
        </div>
        <div class="files">
          <div style="font-weight:700;margin-bottom:6px">Files (${(d.files || []).length})</div>
          <ul>
            ${(d.files || []).map(f => `<li>${escapeHtml(f.filename)} — ${f.status} (<span class="plus">+${f.additions}</span>/<span class="minus">-${f.deletions}</span>)</li>`).join("")}
          </ul>
        </div>
      </div>`;
    stamp(elDetailStamp);
  }

  // --- Periodic Refresh ---
  async function periodicRefresh() {
    console.log("Performing periodic refresh...");
    try {
      // 1. Refresh repo list (mainly for pushed_at time)
      await loadRepos();

      // [OPTIMIZED] Only refresh what is currently visible.
      if (state.selectedRepo) {
        // 2. Refresh branches for the selected repo
        const repo = state.selectedRepo;
        const data = await apiGet('/api/branches', { repo });
        state.branchesCache[repo] = sortBranches(data.branches || []);

        // 3. Refresh commits ONLY for opened branches
        const openedKeys = [...state.openedBranches].filter(k => k.startsWith(repo + '|'));
        await Promise.all(openedKeys.map(key => {
          const [repo, branch] = key.split('|');
          const card = findBranchCard(repo, branch);
          if (card) return loadCommitsForBranch(repo, branch, card);
        }));
      }

      if (state.selectedCommit) {
        await showCommitDetail(state.selectedCommit.repo, state.selectedCommit.sha);
      }
      stampAll();
    } catch (e) {
      console.error("Periodic refresh failed:", e);
    }
  }

  function findBranchCard(repo, branch) {
      // Helper to find the DOM element for a branch to refresh it.
      const branchCards = qsa('.branch-card');
      for (const card of branchCards) {
          const nameEl = card.querySelector('.branch-head .name');
          if (nameEl && nameEl.textContent === branch) {
              return card;
          }
      }
      return null;
  }
</script>
</body>
</html>